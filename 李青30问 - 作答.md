# C-String 30问 - 作答 21122873 郑力铖

```c++
char* StrCpy(char* dest, const char* src){
	char* temp = dest;
    while (*dest++ = *source++) // 1. 请解释本循环的执行过程：何时结束循环，为什么？
        ;						// 	  指针如何变化、指针的目标如何变化？
    return temp;				// 2. 为什么要使用指针变量temp?此处能否改成 return dest;
}
```

1. 依照运算符的优先级，赋值 < 解指针 < 后置自加，即以上循环可以改写为（更易理解的）以下写法：

```c++
do{
	*dest = *src;
    dest++;src++;
}while(*dest == '\0');
```

​		当`dest`指针指向目标字符串的末尾，结束循环。`dest`指向目标string的末端。

2. `dest`的指向在循环后指向指针的最末尾，且无法得知源字符串的长度，需要temp记录最先的指针指向才能有效返回目标串string的头指针。因此不能返回`dest`。



```c++
char* StrCat(char* str1, const char* str2)
{
	char* temp = str1;
	while (*str1)						// 3. 本循环结束时指针str1的目标是什么字符？
		str1++;
	while (*str1++ = *str2++)
		;
	return temp;
}
```

3. 指向string结尾的`'\0'`。



```c++
int StrCmp(const char* str1, char* str2)
{
	unsigned char* p = (unsigned char*)str1;	// 4. 为什么要用另外两个指针变量p和q？
	unsigned char* q = (unsigned char*)str2;
	while (*p && *q && *p == *q)	// 5. 有哪些情况可能导致本循环结束（最好能举例说明）？
		p++, q++;
	return *p > * q ? 1 : (*p < *q ? -1 : 0);	// 6. 串结束标志字符'\0'的值等于多少，起到什么作用？
}
```

4. 保证str的数据范围不越界，在0-255这个区间。
5. `*p == '\0'`, `*q == '\0'`, `*p != *q` 三种情况。
6. `'\0' `在数值上等于0，作用是与其他任意字符作比较。



```c++
int AtoI(const char* str)
{
	int sgn = 1, num = 0, i;
	for (i = 0; str[i] == ' ' || str[i] == '\t' || str[i] == '\n'; i++)
		;
	if (str[i] == '+' || str[i] == '-')
	{
		sgn = (str[i] == '+') ? 1 : -1;
		i++;
	}
	for (; str[i]; i++)
	{
		if ('0' <= str[i] && str[i] <= '9')		// 7. 条件表达式是否能写成 ('0' <= str[i] <= '9') ？
			num = 10 * num + (str[i] - '0');	// 8. 表达式中为什么要减去'0'？
		else
			break;
	}
	return sgn * num;
}
```

7. 不能。假如改成 `'0' <= str[i] <= '9'`这一表达式，因为`[]`的运算优先于`<=`，而`<=`判定时又遵循【从左至右】的原则。因此首先看`'0' <= str[i]`，其值只可能为0或1，再带入到后式，则一定为真。而这并不符合自然语言下对于该判断的语义。

8. `str[i]`是字符串中的数字代表的字符，因为在ASCII编码中数字的编码是连续递增的，减去`'0'`即可得到编码差，即真实的数字值。



```c++
char* GetHeapString(char*& str, const char* source)	// 9. 此处为什么要设计传递指针的引用？
```

9. 方便该字符串既传入数据又传出数据，使用引用增加程序可读性。

```c++
void FreeHeapString(char*& str)
{
	if (str != NULL)
		delete[] str;
	str = NULL;									// 10. 为什么要置str为NULL？
}
```

10. delete仅仅释放内存，但str指针的指向仍指向该内存区域，如果不设置str为空指针，在后续调用时极可能导致内存访问错误，导致程序崩溃。此处设置该指针为空指针极为重要。



```c++
void GetStrings0(char**& dest, const char* const source[], int n)	// 11. 第一个参数为什么要传递二级指针的引用？
{
	dest = new char* [n];
	if (dest == NULL) return;
	dest[0] = new char[n * NUM];
	if (dest[0] == NULL)
	{
		delete[] dest;				// 释放申请成功的堆空间单元
		dest = NULL;
		return;
	}
	for (int i = 1; i < n; i++)					// 12. 请指出本循环的作用
		dest[i] = dest[i - 1] + NUM;
	for (int i = 0; i < n; i++)
	{
		strncpy(dest[i], source[i], NUM);		// 13. 此处为什么要用strncpy函数？
		dest[i][NUM - 1] = '\0';				// 14. 此语句的作用是什么？
	}
}
```

11. 方便该字符串既传入数据又传出数据，使用引用更加简单，返回时直接回到调用点，且可增加程序可读性。
12. 确保接下来的字符串指向字符串的首字符。
13. 防止超长的字符串复制后，损坏内存中的其他数据。
14. 防止超长的字符串复制后，导致结束字符没有存入字符串，从而在接下的工作中无法结束。



```c++
void FreeStrings(char**& strs, int n, bool flag)	// 15. 第一个参数为什么要传递二级指针的引用？
{
	if (strs != NULL)
	{
		if (flag)
		{
			char* temp = strs[0];
			for (int i = 1; i < n; i++)			// 16. 这一段代码的作用是什么？
				if (strs[i] < temp)
					temp = strs[i];
			if (temp != NULL)
				delete[] temp;
		}
		else
		{
			for (int i = 0; i < n; i++)
				if (strs[i] != NULL)
					delete[] strs[i];
		}
		delete[] strs;							// 17. 此处释放的数组是什么数组？
		strs = NULL;
	}
}
```

15. 方便该字符串既传入数据又传出数据，使用引用更加简单，返回时直接回到调用点，且可增加程序可读性。
16. “打擂台”，找到字符串指针最小的地址指针，存到temp，然后删掉。
17. 第一个传入strs的字符串。



```c++
void TestHeapString()
{
	char* str = NULL;		// 18. 此处为什么要将str初始化为NULL，否则会发生什么情况？
	char s[1024];
	cout << "\"" << GetHeapString(str, "Hello") << "\"" << endl;
	cout << "\"" << GetHeapString(str, " world!") << "\"" << endl;
	FreeHeapString(str);
	cout << GetHeapString(str, "请输入一个字符串: ");			// 19. 每执行一次GetHeapString或FreeHeapString函数，str的指向是否发生变化？
	cin.getline(s, 1024);
	cout << "\"" << GetHeapString(str, s) << "\"" << endl;
	FreeHeapString(str);
}
```

18. 防止如果不设置str为空指针，接下来也没有对这个指针做任何操作，则在后续调用时极可能导致内存访问错误，程序崩溃的情况【好习惯】。

19. 是。



```c++
char strA[][NUM] =	{ "enter", "number", "C/C++程序设计", "size", "指针", "begin", "of", "函数", "cat", "case", "program", "certain", "a", "cake", "side" };
char* strB[] =	{ "enter", "number", "C/C++程序设计", "size", "指针", "begin", "of", "函数", "cat", "case", "program", "certain", "an", "cake", "side" };
char** strC = NULL, ** strD = NULL, ** strE = NULL;


// 20. 请尝试先给出如下输出结果，再运行程序验证你的结论
cout << "sizeof(strA) : " << sizeof(strA) << " Bytes,\tsizeof(*strA) : " << sizeof(strA[0]) << " Bytes,\tn1 = " << n1 << "\nsizeof(strB) : " << sizeof(strB) << " Bytes,\tsizeof(*strB) : " << sizeof(strB[0]) << " Bytes,\tn2 = " << n2 << endl;
cout << "\nsizeof(strC) : " << sizeof(strC) << " Bytes"
	 << "\nsizeof(strD) : " << sizeof(strD) << " Bytes"
	 << "\nsizeof(strE) : " << sizeof(strE) << " Bytes" << endl;

GetStrings0(strC, strB0, n0);
GetStrings1(strD, strB0, n0);
GetStrings2(strE, strB0, n0);
//至此，多种存储方式的字符串数组已经全部构造完成。
// 21. 请分别画出strA，strB，strC，strD，strE的结构图，指出它们所在的空间（常量池、栈区、堆区）
```

20. > sizeof(strA) : 300 Bytes, sizeof(\*strA) : 20 Bytes, n1 = 15
    > sizeof(strB) : 120 Bytes, sizeof(\*strB) : 8 Bytes, n2 = 15
    > sizeof(strC) : 8 Bytes
    > sizeof(strD) : 8 Bytes
    > sizeof(strE) : 8 Bytes

21. ![image-20220911151843326](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220911151843326.png)





```c++
ShowStrings("\nstrA 数据: ", strA, n1);
//	BubbleB(strA, n1);	// 22. 此处为什么不能用BubbleB函数？
BubbleA(strA, n1);							
ShowStrin![image-20220911151835110](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220911151835110.png)gs("A排序结果: ", strA, n1);

ShowStrings("\nstrB 数据: ", strB, n2);
//	BubbleA(strB, n2);	// 23. 此处为什么不能用BubbleA函数？（编译能通过，但运行时错）
BubbleB(strB, n2);
ShowStrings("B排序结果: ", strB, n2);
```

22. BubbleB的定义中，形参栏接收指针数组，通过交换指针指向完成冒泡排序，但strA为二维数组，不能用指针数组的方式传递进形参栏。
23. strB中的每个指针指向的目标是常量，不能用修改字符串的内容的方法排序。



```c++
ShowStrings("\nstrC 数据: ", strC, n0);
BubbleB(strC, n0);			// 24. 此处为什么能用BubbleB函数？strC[0]是否被改变？
ShowStrings("B排序结果: ", strC, n0);
FreeStrings(strC, n0, true);// 25. 释放StrC的资源，为什么第三个参数不能采用其默认值false？
GetStrings0(strC, strB0, n0);				// 重新构造无序的StrC
ShowStrings("strC 数据: ", strC, n0);
BubbleA(strC, n0);			// 26. 此处为什么要用BubbleA函数？strC[0]是否被改变？strC[0]的内容是否被改变？
ShowStrings("A排序结果: ", strC, n0);

ShowStrings("\nstrD 数据: ", strD, n0);
BubbleA(strD, n0);			// 27. 此处为什么既可以用BubbleA，又可以用BubbleB函数？
ShowStrings("A排序结果: ", strD, n0);
```

24. strC调用GetString0构建时，字符串全部连续地存储在堆空间内，可交换指针。strC[0]会被改变。
25. 因为strC[0]可能被改变，不能直接delete[]，要两次执行delete[]。
26. BubbleA不改变strC[0]的指向，但是strC[0]的内容改变。
27. strD由GetStrings1构建，每个字符串在内存空间中的容量相等，因此BubbleA与BubbleB都可以。



```c++
ShowStrings("\nstrE 数据: ", strE, n0);
BubbleB(strE, n0);			// 28. 此处为什么不能用BubbleA函数？
ShowStrings("B排序结果: ", strE, n0);

FreeStrings(strE, n0);		// 29. 此处是否可以写成FreeStrings(strE, n0, false);？
FreeStrings(strD, n0);
FreeStrings(strC, n0, true);// 30. 此处是否可以写成FreeStrings(strC, 1);？
```

28. strE由GetString2构成，字符串的长度不固定，交换内容可能导致数组越界。
29. 可以。
30. 可以。